#!/usr/bin/env escript
%% -*- mode: erlang -*-
-include_lib("stdlib/include/qlc.hrl").

-define(REQ,<<"\0REQ">>).
-define(RES,<<"\0RES">>).
-define(CAN_DO, 1).
-define(CANT_DO,2).
-define(RESET_ABILITIES,3).
-define(PRE_SLEEP,4).
-define(NOOP,6).
-define(SUBMIT_JOB, 7).
-define(JOB_CREATED, 8).  %response from SUBMIT_JOB*
-define(GRAB_JOB,9).
-define(NO_JOB,10). %response from GRAB_JOB on empty queue
-define(JOB_ASSIGN,11). %response from GRAB_JOB with work
-define(WORK_COMPLETE,13).
-define(SUBMIT_JOB_BG,18).

% create record types for out DB's
%---------------------------------
% worker record just marks if a worker socket is busy
-record(worker, {sock,state=ready}).
% function record maps the available functions onto the worker sockets
-record(function, {sock,name}).

-record(work, {id,name,data,client_id,client}).

main(_) ->
    % start up mnesia DB
    ok = application:start(mnesia),
    % create our tables, in memory only on local node
    {atomic,ok} = mnesia:create_table(worker, [{ram_copies,[node()]},{type,set},{attributes,record_info(fields,worker)}]),
    {atomic,ok} = mnesia:create_table(function, [{ram_copies,[node()]},{type,bag},{attributes,record_info(fields,function)}]),

    % create our memory + disk tables:
    {atomic,ok} = mnesia:create_table(work, [{ram_copies,[node()]},{type,bag},{attributes,record_info(fields,work)}]),

    % make sure tables are created before we continue
    ok = mnesia:wait_for_tables([worker,function],infinity),
    
    % bind to our listn port then start acceptint connections
    {ok, ListenSocket} = gen_tcp:listen(8888, [{active,once}, binary, {reuseaddr, true}]),
    spawn(fun() -> acceptor(ListenSocket) end),
    timer:sleep(infinity).

acceptor(ListenSocket) ->
    {ok, Socket} = gen_tcp:accept(ListenSocket),
    spawn(fun() -> acceptor(ListenSocket) end),
    handle(Socket).

dbq(QLC)->
    {atomic, Result} = mnesia:transaction(fun() -> qlc:e(QLC) end),
    Result.

handle(Socket) ->
    inet:setopts(Socket, [{active, once}]),
    receive
        {tcp, Socket, <<"status\r\n">>} ->
            report_status(Socket);
        {tcp, Socket, Message} ->
            % we might get several seperate protocol requests in one Message, so use binary comprehension to
            % split them up and call handle_message for each
            [ handle_message(Socket, Req, Type, Data) || <<Req:4/binary, Type:32, Length:32, Data:Length/binary>> <= Message ],
            handle(Socket);
        {tcp_closed, Socket} ->
            mnesia:transaction(
              fun() -> 
                      dbq(qlc:q([mnesia:delete({function, X#function.sock}) || X <- mnesia:table(function), X#function.sock =:= Socket])),
                      dbq(qlc:q([mnesia:delete({worker, X#worker.sock})     || X <- mnesia:table(worker),   X#worker.sock =:= Socket]))
              end
             );
        UnhandledMessage -> io:format("unhandled message: ~p~n", [UnhandledMessage])
    end.

handle_message(Worker,?REQ, ?CAN_DO, Data)->
    io:format("==> worker register: ~p~n",[Data]),
    % load out new worker into the DB
    WorkerRec = #worker{sock=Worker},
    FuncRec = #function{name=Data,sock=Worker},
    mnesia:transaction(fun() -> mnesia:write(WorkerRec), mnesia:write(FuncRec) end);

handle_message(Worker,?REQ,?CANT_DO,Data) ->
    io:format("==> worker unregister: ~p~n",[Data]),
    mnesia:transaction(fun() -> mnesia:delete({function,Worker}) end);

% this is a SYNC job, it will not be inserted into the queue
handle_message(Client, ?REQ, ?SUBMIT_JOB, Data)->
    io:format("==> client: ~p SUBMIT_JOB~n", [Client]),
    submit_job(Client,Client,Data);

handle_message(Client, ?REQ, ?SUBMIT_JOB_BG, Data) ->
    io:format("==> client: ~p SUBMIT_JOB_BG~n", [Client]),
    submit_job(Client,null,Data);

handle_message(Worker,?REQ, ?GRAB_JOB,_Data)->
    io:format("==> worker: ~p GRAB_JOB~n", [Worker]),
    Work = find_work(Worker),
    if Work =:= null ->       
            io:format("<== worker: ~p NO_JOB~n", [Worker]),
            send_response(Worker,?NO_JOB,<<>>);
       true ->
            Workload = list_to_binary([Work#work.id,0,Work#work.name,0,Work#work.data]),

            % update our state to mark the worker busy so we dont send it more work
            WorkerRec = #worker{sock=Worker,state=busy},
            mnesia:transaction(fun() -> mnesia:write(WorkerRec) end),
            io:format("<== worker: ~p JOB_ASSIGN~n", [Worker]),
            send_response(Worker, ?JOB_ASSIGN, Workload)
    end;

handle_message(Worker,?REQ, ?PRE_SLEEP,_Data)->
    io:format("==> worker: ~p PRE_SLEEP~n", [Worker])
    %% do we need to update worker.state to "asleep" or
    %% do we just send NOOP RES to workers anytime
    %% we want them to do work?
    ;

handle_message(Worker,?REQ, ?WORK_COMPLETE, Data) ->
    io:format("==> worker: ~p WORK_COMPLETE~n", [Worker]),
    %% FIXME should use binary:split here, but not available in my 
    %% erlang version R13B03
    [A|_] = string:tokens(binary_to_list(Data),"\0"),
    ID = list_to_binary(A),

    % the worker is available to do work again
    WorkerRec = #worker{sock=Worker,state=ready},
    mnesia:transaction(fun() -> mnesia:write(WorkerRec) end),

    % find the job just completed
    [Job|_] = dbq(qlc:q([J || J <- mnesia:table(work),
                              J#work.id =:= ID])),
    mnesia:transaction(fun() -> mnesia:delete({work,Job#work.id}) end),

    if Job#work.client =/= null ->
            io:format("<== client: ~p WORK_COMPLETE~n", [Job#work.client]),
            send_response(Job#work.client, ?WORK_COMPLETE, Data);
       true -> noop
    end;

% this ones goes last to alert us something didnt get handled properly
handle_message(_Socket, Req, Type, Data) ->
    io:format("got unknown message req:~p type:~p data:~p~n", [Req,Type,Data]).

send_response(Socket, Type, Data) ->
    Len=byte_size(Data),
    gen_tcp:send(Socket, [?RES, <<Type:32, Len:32>>, Data]).

submit_job(Client, RespondTo, Data) ->
    Job = mkjob(RespondTo,Data),
    mnesia:transaction(fun() -> mnesia:write(Job) end),
    io:format("<== client: ~p JOB_CREATED~n", [Client]),
    send_response(Client,?JOB_CREATED,Job#work.id),
    spawn( fun() -> wakeup_worker(Job) end ).

wakeup_worker(Job) ->
    Worker = find_worker(Job),
    if Worker =/= null ->
            io:format("<== worker: ~p NOOP~n", [Worker]),
            send_response(Worker,?NOOP,<<>>);
       true -> noop
    end.
    
find_worker(Job) ->
    Workers = dbq(qlc:q([W#worker.sock || W <- mnesia:table(worker),
                                          W#worker.state =:= ready,
                                          F <- mnesia:table(function),
                                          W#worker.sock =:= F#function.sock,
                                          F#function.name =:= Job#work.name ])),
    case Workers of
        [Worker|_] -> Worker;
        [] -> null
    end.

find_work(Worker) ->
    Jobs = dbq(qlc:q([J || J <- mnesia:table(work),
                           F <- mnesia:table(function),
                           J#work.name =:= F#function.name,
                           F#function.sock =:= Worker ])),
    case Jobs of
        [Job|_] -> Job;
        [] -> null
    end.

mkjob(Client,Data) ->
    %% FIXME should use binary:split here, but not available in my 
    %% erlang version R13B03
    [A, B|C] = string:tokens(binary_to_list(Data),"\0"),
    Function = list_to_binary(A),
    ID = list_to_binary(B),
    Work = list_to_binary(C),
    UUID = list_to_binary(uuid:to_string(uuid:v4())),
    #work{id=UUID,name=Function,data=Work,client_id=ID,client=Client}.

report_status(Socket)->
    dbq(qlc:q([ io:format("report worker: ~p~n", [X]) || X <- mnesia:table(worker) ])),
    dbq(qlc:q([ io:format("report function: ~p~n", [X]) || X <- mnesia:table(function) ])),
    dbq(qlc:q([ io:format("report work: ~p~n", [X]) || X <- mnesia:table(work) ])),
    gen_tcp:send(Socket,<<"TODO\n">>).
